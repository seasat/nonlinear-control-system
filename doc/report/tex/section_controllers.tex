
\section{Controller Design}
\subsection{State Space}
The system can be represented in state space form, where the state vector depends on the attitude representation used.
The control problem is a second order system, where the controller acts on the torque which is in turn integrated twice to obtain the attitude, which is the control variable.
As such both the attitude and the angular velocity form part of the state vector.

\parbox{.49\linewidth}{
\begin{equation}
    \gls{sy:x_dot} =
    \begin{bmatrix}
        \gls{sy:ypr_dot} \\
        \gls{sy:omega_dot}
    \end{bmatrix}
\end{equation}
}
\parbox{.49\linewidth}{
\begin{equation}
    \gls{sy:x_dot} =
    \begin{bmatrix}
        \gls{sy:q_dot} \\
        \gls{sy:omega_dot}
    \end{bmatrix}
\end{equation}
}

\gls{sy:omega_dot} is defined by the dynamics of the system and calculated through ???.
\gls{sy:ypr_dot} and \gls{sy:q_dot} arise from the kinematics of the system and are calculated through \cref{eqt:omega_to_theta_dot,eqt:omega_to_q_dot}.
Both cases are highly nonlinear systems, to which different control strategies are subsequently applied.


\subsection{Linear Controller}
A linear controller is designed using a linear system, where the state vector derivative is a linear combination of both the state vector itself and the control input (see \cref{eqt:state_space_linear}).
\begin{equation} \label{eqt:state_space_linear}
    \gls{sy:x_dot} = \mat{A} \gls{sy:x} + \mat{B} \gls{sy:u}
\end{equation}

One possible solution to obtaining a linear model of a nonlinear system is to linearize it around the operation point, which in this case in the nadir pointing with no angular velocity.
The linearization uses a Taylor expansion that is then truncated after the first order term.

Specifically, this results in the following approximations: $\sin{x_i} \approx x_i$, $\cos{x_i} \approx 1$ and $x_i x_j \approx 0$.
This results in the following linear descriptions of the system around the operation point $\gls{sy:x} = \vec{0}$ and $\gls{sy:u} = \vec{0}$:

\parbox{.49\linewidth}{
\begin{equation}
    \gls{sy:x_dot} = 
    \begin{bmatrix}
        0 & 0 & \gls{sy:mean_motion} & 1 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 0 & 0 & 1 \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0
    \end{bmatrix}
    \begin{bmatrix}
        \gls{sy:roll} \\
        \gls{sy:pitch} \\
        \gls{sy:yaw} \\
        \omega_1 \\
        \omega_2 \\
        \omega_3
    \end{bmatrix}
    + \begin{bmatrix}
        0 \\
        \gls{sy:j}^{-1}
    \end{bmatrix}
    \gls{sy:t_c}
\end{equation}
}
\parbox{.49\linewidth}{
\begin{equation}
    \gls{sy:x_dot} = 
    \begin{bmatrix}
        0 & 0 & 0 & 0.5 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0.5 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0.5 \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0
    \end{bmatrix}
    \begin{bmatrix}
        q_1 \\
        q_2 \\
        q_3 \\
        \omega_1 \\
        \omega_2 \\
        \omega_3
    \end{bmatrix}
    + \begin{bmatrix}
        0 \\
        \gls{sy:j}^{-1}
    \end{bmatrix}
    \gls{sy:t_c}
\end{equation}
}

This is evidently heavily linearized and misses much of the behavior of the system.
It does however allow for the design of a controller that will perform according to the specifications for small angles, angular velocities and torques.
Using state feedback control, the control output is defined as 
\begin{equation}
    \gls{sy:u} = -\gls{sy:K} \gls{sy:x}
\end{equation}

Using the \texttt{place} function of Python's \texttt{control} package, the gain matrix \gls{sy:K} can be calculated such that the closed loop poles of the system are at the desired locations.

The resulting gains for Euler angles:
\begin{equation}
    \gls{sy:K} = \begin{bmatrix}
        1.245&	0.000&	0.02377&	22.42&	0.000&	0.1320 \\
        0.000	&1.246	&0.000&	0.000&	22.43&	0.000 \\
        0.000	&0.000	&0.01704&	0.000&	0.000&	0.3067 \\
    \end{bmatrix}
\end{equation}

Using quaternions:
\begin{equation}
    \gls{sy:K} = \begin{bmatrix}
        2.491&	0.000&	0.000&	22.42&	0.000&	0.000\\
        0.000&	2.492&	0.000&	0.000& 22.43&	0.000\\
        0.000&	0.000& 	0.03408&	0.000&	0.000&	0.3067\\	
    \end{bmatrix}
\end{equation}


\subsection{\texorpdfstring{\acrlong{pd}}{Proportional Differential} Controller}
\subsection{\texorpdfstring{\acrlong{ndi}}{Nonlinear Dynamic Inversion}}
\subsection{\texorpdfstring{\acrlong{tss}}{Time Scale Separation}}
\subsection{\texorpdfstring{\acrlong{indi}}{Incremental Dynamic Inversion}}